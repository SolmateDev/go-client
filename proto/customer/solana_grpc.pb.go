// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.3
// source: zzzz-customer-solana.proto

package customer

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	base "github.com/SolmateDev/go-client/proto/base"
	job "github.com/SolmateDev/go-client/proto/job"
	solana "github.com/SolmateDev/go-client/proto/solana"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// SolanaClient is the client API for Solana service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SolanaClient interface {
	LinkAccount(ctx context.Context, in *solana.LinkRequest, opts ...grpc.CallOption) (*solana.LinkResponse, error)
	SubscribeAccount(ctx context.Context, in *solana.AccountSubscribeRequest, opts ...grpc.CallOption) (Solana_SubscribeAccountClient, error)
	CreateValidator(ctx context.Context, in *solana.ValidatorCreateRequest, opts ...grpc.CallOption) (*job.Job, error)
	ListValidator(ctx context.Context, in *base.Empty, opts ...grpc.CallOption) (*solana.ValidatorList, error)
	DestroyValidator(ctx context.Context, in *solana.ValidatorDeleteRequest, opts ...grpc.CallOption) (*base.Empty, error)
	SendTx(ctx context.Context, in *solana.SendBatchRequest, opts ...grpc.CallOption) (*solana.SendBatchResponse, error)
}

type solanaClient struct {
	cc grpc.ClientConnInterface
}

func NewSolanaClient(cc grpc.ClientConnInterface) SolanaClient {
	return &solanaClient{cc}
}

func (c *solanaClient) LinkAccount(ctx context.Context, in *solana.LinkRequest, opts ...grpc.CallOption) (*solana.LinkResponse, error) {
	out := new(solana.LinkResponse)
	err := c.cc.Invoke(ctx, "/customer.Solana/LinkAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *solanaClient) SubscribeAccount(ctx context.Context, in *solana.AccountSubscribeRequest, opts ...grpc.CallOption) (Solana_SubscribeAccountClient, error) {
	stream, err := c.cc.NewStream(ctx, &Solana_ServiceDesc.Streams[0], "/customer.Solana/SubscribeAccount", opts...)
	if err != nil {
		return nil, err
	}
	x := &solanaSubscribeAccountClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Solana_SubscribeAccountClient interface {
	Recv() (*solana.AccountSubscribeResponse, error)
	grpc.ClientStream
}

type solanaSubscribeAccountClient struct {
	grpc.ClientStream
}

func (x *solanaSubscribeAccountClient) Recv() (*solana.AccountSubscribeResponse, error) {
	m := new(solana.AccountSubscribeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *solanaClient) CreateValidator(ctx context.Context, in *solana.ValidatorCreateRequest, opts ...grpc.CallOption) (*job.Job, error) {
	out := new(job.Job)
	err := c.cc.Invoke(ctx, "/customer.Solana/CreateValidator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *solanaClient) ListValidator(ctx context.Context, in *base.Empty, opts ...grpc.CallOption) (*solana.ValidatorList, error) {
	out := new(solana.ValidatorList)
	err := c.cc.Invoke(ctx, "/customer.Solana/ListValidator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *solanaClient) DestroyValidator(ctx context.Context, in *solana.ValidatorDeleteRequest, opts ...grpc.CallOption) (*base.Empty, error) {
	out := new(base.Empty)
	err := c.cc.Invoke(ctx, "/customer.Solana/DestroyValidator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *solanaClient) SendTx(ctx context.Context, in *solana.SendBatchRequest, opts ...grpc.CallOption) (*solana.SendBatchResponse, error) {
	out := new(solana.SendBatchResponse)
	err := c.cc.Invoke(ctx, "/customer.Solana/SendTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SolanaServer is the server API for Solana service.
// All implementations must embed UnimplementedSolanaServer
// for forward compatibility
type SolanaServer interface {
	LinkAccount(context.Context, *solana.LinkRequest) (*solana.LinkResponse, error)
	SubscribeAccount(*solana.AccountSubscribeRequest, Solana_SubscribeAccountServer) error
	CreateValidator(context.Context, *solana.ValidatorCreateRequest) (*job.Job, error)
	ListValidator(context.Context, *base.Empty) (*solana.ValidatorList, error)
	DestroyValidator(context.Context, *solana.ValidatorDeleteRequest) (*base.Empty, error)
	SendTx(context.Context, *solana.SendBatchRequest) (*solana.SendBatchResponse, error)
	mustEmbedUnimplementedSolanaServer()
}

// UnimplementedSolanaServer must be embedded to have forward compatible implementations.
type UnimplementedSolanaServer struct {
}

func (UnimplementedSolanaServer) LinkAccount(context.Context, *solana.LinkRequest) (*solana.LinkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LinkAccount not implemented")
}
func (UnimplementedSolanaServer) SubscribeAccount(*solana.AccountSubscribeRequest, Solana_SubscribeAccountServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeAccount not implemented")
}
func (UnimplementedSolanaServer) CreateValidator(context.Context, *solana.ValidatorCreateRequest) (*job.Job, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateValidator not implemented")
}
func (UnimplementedSolanaServer) ListValidator(context.Context, *base.Empty) (*solana.ValidatorList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListValidator not implemented")
}
func (UnimplementedSolanaServer) DestroyValidator(context.Context, *solana.ValidatorDeleteRequest) (*base.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyValidator not implemented")
}
func (UnimplementedSolanaServer) SendTx(context.Context, *solana.SendBatchRequest) (*solana.SendBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendTx not implemented")
}
func (UnimplementedSolanaServer) mustEmbedUnimplementedSolanaServer() {}

// UnsafeSolanaServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SolanaServer will
// result in compilation errors.
type UnsafeSolanaServer interface {
	mustEmbedUnimplementedSolanaServer()
}

func RegisterSolanaServer(s grpc.ServiceRegistrar, srv SolanaServer) {
	s.RegisterService(&Solana_ServiceDesc, srv)
}

func _Solana_LinkAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(solana.LinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolanaServer).LinkAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/customer.Solana/LinkAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolanaServer).LinkAccount(ctx, req.(*solana.LinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Solana_SubscribeAccount_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(solana.AccountSubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SolanaServer).SubscribeAccount(m, &solanaSubscribeAccountServer{stream})
}

type Solana_SubscribeAccountServer interface {
	Send(*solana.AccountSubscribeResponse) error
	grpc.ServerStream
}

type solanaSubscribeAccountServer struct {
	grpc.ServerStream
}

func (x *solanaSubscribeAccountServer) Send(m *solana.AccountSubscribeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Solana_CreateValidator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(solana.ValidatorCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolanaServer).CreateValidator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/customer.Solana/CreateValidator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolanaServer).CreateValidator(ctx, req.(*solana.ValidatorCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Solana_ListValidator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(base.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolanaServer).ListValidator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/customer.Solana/ListValidator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolanaServer).ListValidator(ctx, req.(*base.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Solana_DestroyValidator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(solana.ValidatorDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolanaServer).DestroyValidator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/customer.Solana/DestroyValidator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolanaServer).DestroyValidator(ctx, req.(*solana.ValidatorDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Solana_SendTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(solana.SendBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolanaServer).SendTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/customer.Solana/SendTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolanaServer).SendTx(ctx, req.(*solana.SendBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Solana_ServiceDesc is the grpc.ServiceDesc for Solana service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Solana_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "customer.Solana",
	HandlerType: (*SolanaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LinkAccount",
			Handler:    _Solana_LinkAccount_Handler,
		},
		{
			MethodName: "CreateValidator",
			Handler:    _Solana_CreateValidator_Handler,
		},
		{
			MethodName: "ListValidator",
			Handler:    _Solana_ListValidator_Handler,
		},
		{
			MethodName: "DestroyValidator",
			Handler:    _Solana_DestroyValidator_Handler,
		},
		{
			MethodName: "SendTx",
			Handler:    _Solana_SendTx_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeAccount",
			Handler:       _Solana_SubscribeAccount_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "zzzz-customer-solana.proto",
}
